<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>运维s on </title>
    <link>/%E8%BF%90%E7%BB%B4/</link>
    <description>Recent content in 运维s on </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 23 Oct 2019 16:08:36 +0800</lastBuildDate>
    
	<atom:link href="/%E8%BF%90%E7%BB%B4/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>docker clean volume</title>
      <link>/%E8%BF%90%E7%BB%B4/docker-volume-clean/</link>
      <pubDate>Wed, 23 Oct 2019 16:08:36 +0800</pubDate>
      
      <guid>/%E8%BF%90%E7%BB%B4/docker-volume-clean/</guid>
      <description>docker 磁盘清理 自动清理 docker system prune 已使用的镜像：指所有已被容器（包括stop的）关联的镜像，也就是docker ps -a所看到的所有容器对应的image。 未引用镜像：没有被分配或使用在容器中的镜像 悬空镜像（dangling image）：未配置任何Tag（也就是无法被引用）的镜像。通常是由于镜像编译过程中未指定-t参数配置Tag导致的。
docker system prune后可以加额外的参数，如： docker system prune -a ： 一并清除所有未被使用的镜像和悬空镜像。 docker system prune -f ： 用以强制删除，不提示信息。
docker image prune：删除悬空的镜像。
docker container prune：删除无用的容器。 &amp;ndash;默认情况下docker container prune命令会清理掉所有处于stopped状态的容器 &amp;ndash;如果不想那么残忍统统都删掉，也可以使用&amp;ndash;filter标志来筛选出不希望被清理掉的容器。例子：清除掉所有停掉的容器，但24内创建的除外： &amp;ndash;$ docker container prune &amp;ndash;filter &amp;ldquo;until=24h&amp;rdquo;
docker volume prune：删除无用的卷。 docker network prune：删除无用的网络
手动清除 对于悬空镜像和未使用镜像可以使用手动进行个别删除： 1、删除所有悬空镜像，不删除未使用镜像： docker rmi $(docker images -f &amp;ldquo;dangling=true&amp;rdquo; -q) 2、删除所有未使用镜像和悬空镜像 docker rmi $(docker images -q) 3、清理卷 如果卷占用空间过高，可以清除一些不使用的卷，包括一些未被任何容器调用的卷（-v 详细信息中若显示 LINKS = 0，则是未被调用）： 删除所有未被容器引用的卷： docker volume rm $(docker volume ls -qf dangling=true) 4、容器清理 如果发现是容器占用过高的空间，可以手动删除一些： 删除所有已退出的容器： 对于悬空镜像和未使用镜像可以使用手动进行个别删除： 1、删除所有悬空镜像，不删除未使用镜像： docker rmi $(docker images -f &amp;ldquo;dangling=true&amp;rdquo; -q) 2、删除所有未使用镜像和悬空镜像 docker rmi $(docker images -q) 3、清理卷 如果卷占用空间过高，可以清除一些不使用的卷，包括一些未被任何容器调用的卷（-v 详细信息中若显示 LINKS = 0，则是未被调用）： 删除所有未被容器引用的卷： docker volume rm $(docker volume ls -qf dangling=true) 4、容器清理 如果发现是容器占用过高的空间，可以手动删除一些： 删除所有已退出的容器：</description>
    </item>
    
    <item>
      <title>ovftool usage</title>
      <link>/%E8%BF%90%E7%BB%B4/ovftool/</link>
      <pubDate>Wed, 23 Oct 2019 16:08:36 +0800</pubDate>
      
      <guid>/%E8%BF%90%E7%BB%B4/ovftool/</guid>
      <description>export ovf ovftool vi://root@8.16.0.119:443/template ./
目的：可以实现跨越物理机克隆esxi虚拟机 利用VMware workstation（本人使用的pro版）的 OVF Tool导出。 假设你的ESXi的服务器ip是172.28.1.1，要备份的虚拟机的名字叫做ubuntu，workstation装在windows上。
首先进入VMware workstation安装目录，找到\OVFTool\ovftool.exe，执行命令 .\ovftool.exe vi://root:@172.28.1.1/ubuntu C: 输入ESXi root用户的密码后，备份开始，保存在windows的C盘中，至少要包含一个ovf文件和一个vmdk文件。 OVF的全称是Open Virtualization Format。
直接拷贝虚拟机的vmdk文件也是可以的，但是如果虚拟机的硬盘是厚制备的话，vmdk文件太大了。举个例子，我的ubuntu虚拟机vmdk文件大小500GB，导出为OVF后只需要大约10GB。另外OVFTool应该是开源软件，如果你不想安装VMware家的workstation，可以找一找开源的OVFTool。 blog.csdn.net/weixin_43808555/article/details/919720323/terraform-provider-esxi_v1.5.3 参考链接</description>
    </item>
    
    <item>
      <title>yum install rpm</title>
      <link>/%E8%BF%90%E7%BB%B4/yum/</link>
      <pubDate>Wed, 23 Oct 2019 16:08:36 +0800</pubDate>
      
      <guid>/%E8%BF%90%E7%BB%B4/yum/</guid>
      <description>download rpm package yum install &amp;ndash;downloadonly RPM_Name
download rpm package to target dir yum install &amp;ndash;downloadonly &amp;ndash;downloaddir=/usr/package rpm_name
yum install remote file server rpm yum localinstall http://{{ nginx_file_server }}/rpm</description>
    </item>
    
    <item>
      <title>shell 判断</title>
      <link>/%E8%BF%90%E7%BB%B4/shell_judge/</link>
      <pubDate>Fri, 04 Oct 2019 16:08:36 +0800</pubDate>
      
      <guid>/%E8%BF%90%E7%BB%B4/shell_judge/</guid>
      <description>shell判断文件,目录是否存在或者具有权限
#!/bin/sh myPath=&amp;quot;/var/log/httpd/&amp;quot; myFile=&amp;quot;/var /log/httpd/access.log&amp;quot;  这里的-x 参数判断$myPath是否存在并且是否具有可执行权限 if [ ! -x &amp;quot;$myPath&amp;quot;]; then mkdir &amp;quot;$myPath&amp;quot; fi  这里的-d 参数判断$myPath是否存在 if [ ! -d &amp;quot;$myPath&amp;quot;]; then mkdir &amp;quot;$myPath&amp;quot; fi  这里的-f参数判断$myFile是否存在 if [ ! -f &amp;quot;$myFile&amp;quot; ]; then touch &amp;quot;$myFile&amp;quot; fi  其他参数还有-n,-n是判断一个变量是否是否有值 if [ ! -n &amp;quot;$myVar&amp;quot; ]; then echo &amp;quot;$myVar is empty&amp;quot; exit 0 fi  两个变量判断是否相等 if [ &amp;quot;$var1&amp;quot; = &amp;quot;$var2&amp;quot; ]; then echo &#39;$var1 eq $var2&#39; else echo &#39;$var1 not eq $var2&#39; fi  -a file exists.</description>
    </item>
    
    <item>
      <title></title>
      <link>/%E8%BF%90%E7%BB%B4/windows-install/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E8%BF%90%E7%BB%B4/windows-install/</guid>
      <description>##硬盘分区表格式GUID和MBR知识普及
MBR 主引导记录（Master Boot Record，缩写：MBR），又叫做主引导扇区，是计算机开机后访问硬盘时所必须要读取的首个扇区，它在硬盘上的三维地址为（柱面，磁头，扇区）＝（0，0，1）。 MBR是由分区程序（如Fdisk，Parted）所产生的，它不依赖任何操作系统，而且硬盘引导程序也是可以改变的，从而能够实现多系统引导。 从主引导记录的结构可以知道，它仅仅包含一个64个字节的硬盘分区表。由于每个分区信息需要16个字节，所以对于采用MBR型分区结构的硬盘(其磁盘卷标类型为MS-DOS)，最多只能识别4个主要分区。所以对于一个采用此种分区结构的硬盘来说，想要得到4个以上的主要分区是不可能的。这里就需要引出扩展分区了。扩展分区也是主分区（Primary partition）的一种，但它与主分区的不同在于理论上可以划分为无数个逻辑分区，每一个逻辑分区都有一个和MBR结构类似的扩展引导记录(EBR)。在MBR分区表中最多4个主分区或者3个主分区＋1个扩展分区，也就是说扩展分区只能有一个，然后可以再细分为多个逻辑分区。 在Linux系统中，硬盘分区命名为sda1－sda4或者hda1－hda4（其中a表示硬盘编号可能是a、b、c等等）。在MBR硬盘中，分区号1－4是主分区（或者扩展分区），逻辑分区号只能从5开始。 在MBR分区表中，一个分区最大的容量为2T，且每个分区的起始柱面必须在这个disk的前2T内。你有一个3T的硬盘，根据要求你至少要把它划分为2个分区，且最后一个分区的起始扇区要位于硬盘的前2T空间内。如果硬盘太大则必须改用GPT。 GPT 全局唯一标识分区表（GUID Partition Table，缩写：GPT）是一个实体硬盘的分区结构。它是EFI(可扩展固件接口标准)的一部分，用来替代BIOS中的主引导记录分区表。但因为MBR分区表不支持容量大于2.2TB（2.2 × 1012字节）的分区，所以也有一些BIOS系统为了支持大容量硬盘而用GPT分区表取代MBR分区表。 在MBR硬盘中，分区信息直接存储于主引导记录(MBR)中（主引导记录中还存储着系统的引导程序）。但在GPT硬盘中，分区表的位置信息储存在GPT头中。但出于兼容性考虑，硬盘的第一个扇区仍然用作MBR，之后才是GPT头。 与支持最大卷为2 TB（Terabytes）并且每个磁盘最多有4个主分区（或3个主分区，1个扩展分区和无限制的逻辑驱动器）的MBR磁盘分区的样式相比，GPT磁盘分区样式支持最大卷为18 EB（Exabytes）（1EB=1048576TB）并且每磁盘的分区数没有上限，只受到操作系统限制（由于分区表本身需要占用一定空间，最初规划硬盘分区时，留给分区表的空间决定了最多可以有多少个分区，IA-64版Windows限制最多有128个分区，这也是EFI标准规定的分区表的最小尺寸）。与MBR分区的磁盘不同，至关重要的平台操作数据位于分区，而不是位于非分区或隐藏扇区。另外，GPT分区磁盘有备份分区表来提高分区数据结构的完整性。 其中转换为GPT的时候可以创建两个隐藏分区，ESP和MSR。ESP是efi系统分区用于保存引导文件，MSR是微软的保留分区，用于安装操作系统。 简单说明☆： 说了这么多，如果你是第一看这方面的东西的话，很有可能看不太懂，没关系！这里有简单的介绍。 1. MBR分区表：Master Boot Record，即硬盘主引导记录分区表，只支持容量在 2.1TB 以下的硬盘，超过2.1TB的硬盘只能管理2.1TB，最多只支持4个主分区或三个主分区和一个扩展分区，扩展分区下可以有多个逻辑分区。 2. GPT分区表：GPT，全局唯一标识分区表(GUID Partition Table)，与MBR最大4个分区表项的限制相比，GPT对分区数量没有限制，但Windows最大仅支持128个GPT分区，GPT可管理硬盘大小达到了18EB。只有基于UEFI平台的主板才支持GPT分区引导启动。 GPT分区表下的隐藏分区： ①. ESP分区：EFI system partition，该分区用于采用了EFI BIOS的电脑系统，用来启动操作系统。分区内存放引导管理程序、驱动程序、系统维护工具等。如果电脑采用了EFI系统，或当前磁盘用于在EFI平台上启动操作系统，则应建议ESP分区。 ②. MSR分区：即微软保留分区，是GPT磁盘上用于保留空间以备用的分区，例如在将磁盘转换为动态磁盘时需要使用这些分区空间。 两种硬盘分区模式分别对应的BIOS启动方式： 硬盘分区格式为MBR格式，启动模式应该为Legacy； 硬盘分区格式为GUID（GPT）格式，启动模式应该为UEFI。 当把这些调整好之后，按着上篇博客中U盘装系统的方法，就可以安装你想要的操作系统了！  </description>
    </item>
    
    <item>
      <title>ansible useage</title>
      <link>/%E8%BF%90%E7%BB%B4/ansible/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E8%BF%90%E7%BB%B4/ansible/</guid>
      <description>基本概念 Tasks：任务，由模板定义的操作列表 Variables：变量 Templates：模板，即使用模板语法的文件 Handlers：处理器 ，当某条件满足时，触发执行的操作 Roles：角色
定制返回信息 official example
modify config bin_ansible_callbacks = True callback_plugins = callback_plugins callback_whitelist = self_logout  task cost time codes
命令行工具 ansible
ansible-playbook
常用 modules  yum fetch copy shell  template 和 wget 下载文件的速度对比 wget 要比 template 快
shell: wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo
template: src: templates/docker-ce.repo dest: /etc/yum.repos.d/docker-ce.repo
yum 是否可以 多个一起
优化大量的shell一起执行的速度 回掉脚本 python ansible api ansible 数组写在一行不好看 playbook的YAML格式： 文件的起始： &amp;mdash; 以三个减号开头，也可以不用，不会影响Ansible的运行 注释： # 像Python一样用一个#进行注释 字符串： 可以使用引号或者不使用，即使字符串中含有空格，也不完全使用引号 布尔值： True | False 列表： 列表使用-作为分隔符： - zhangsan - lisi - wangwu 也可以使用内联格式： [zhangsan,lisi,wangwu] 字典： YAML中的字典类似于JSON中的对象，Python中的字典： address: beijing city: beijing state: North 也可以使用内联格式： {address: beijing, city: beijing, state: North} 折行： YAML中使用大于号(&amp;gt;)来标记折行，YAML解释器会把换行符替换为空格： address: &amp;gt; Deadfasdfadf, sdfdsfdsfsd 模块： apt：使用apt包管理工具安装或删除软件包 copy：将一个文件从本地复制到主机上 file：设置文件、符号链接或者目录的属性 service：启动、停止或者重启一个服务 template：从模板生成一个文件并复制到主机上 handler： handler是Ansible提供的条件机制之一。handler和task很类似，但是它只是在被task通知的时候才会执行。 notify: restart nginx handler只会在所有任务执行完后执行。而且即使被通知了多次，它也只会执行一次。handler按照play中定义的顺序 执行，而不是被通知的顺序。</description>
    </item>
    
  </channel>
</rss>